## 거품 정렬, Bubble Sort

> 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘
→ 인접한 두 개의 레코드를 비교하여 크기가 순차적이지 않으면 서로 교환함
>

<br/>

### 1. 알고리즘 (오름차순 정렬)

1. 1, 2번째 자료들을 비교하고 정렬하고 2, 3번째 자료를 비교하고 정렬하고… n-1, n번째 자료들을 비교하고 정렬한다
2. 1번을 수행하고 나면 가장 큰 자료가 가장 뒤로 이동하므로 비교를 다시 할 때는 맨 끝 자료(가장 큰 자료)는 정렬에서 제외하고 n-1개를 대상으로 1번을 다시 수행한다

![image](https://github.com/eunjjungg/TIL/assets/100047095/43352764-4c6f-4300-8310-5327a803391b)

출처 : https://gmlwjd9405.github.io/2018/05/06/algorithm-bubble-sort.html

<br/>

### 2. 복잡도

**시간복잡도**

| best | avg | worst |
| --- | --- | --- |
| n^2 | n^2 | n^2 |

**공간복잡도**

다른 자료구조를 사용하지 않음. 인접한 두 개의 값에 대해서만 비교를 진행하기 때문에 in-place 알고리즘임.

<br/>

### 3. code

```kotlin
// 바깥쪽 loop(배열을 순회할 횟수)
for (i in 0 until n - 1) {
    var isSwap = false
    // 안쪽 loop(swap 여부를 판단할 횟수)
    // 바깥쪽 loop가 한 번 돌 때마다 배열의 끝에 정렬된 값이 들어오므로 n - 1 - i
    for (j in 0 until n - 1 - i) {
        if (array[j] > array[j + 1]) {
            swap(array, j, j + 1)
            isSwap = true
        }
    }

    // 정렬이 완료된 경우 바로 return (시간복잡도 감소)
    if (!isSwap) {
        return
    }
}
```

위의 코드는 최적화가 된 코드로 swap을 확인하는 flag를 두고 정렬이 완료되어 swap이 false 그대로라면 정렬을 종료함.

<br/>

### 4. 장단점

**장점**

- 구현이 간단하고, 코드가 직관적이다.
- 제자리 정렬의 일종으로 공간복잡도가 O(n)이다.
- 안정 정렬이므로 중복된 값이 입력 순서와 동일하게 정렬된다.

**단점**

- 시간복잡도가 최악/최선/평균 모두 O(n^2)으로 매우 비효율적이다.
- 특정 요소가 최종 정렬 위치에 있는 경우라도 교환이 일어난다.
- 일반적으로 자료의 교환(swap) 작업이 이동(move) 작업보다 더 복잡하다.