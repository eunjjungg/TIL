## 선택 정렬, Selection Sort

> 선택 정렬과 거품 정렬은 유사한 알고리즘. <br/>
> 해당 순서에 원소를 넣을 위치는 정해져있고 그 위치에 넣을 원소를 선택하는 알고리즘임.
>

<br/>

### 1. 알고리즘 (오름차순 정렬)

1. 주어진 배열의 최솟값 찾기
2. 맨 앞의 원소와 1에서 찾아낸 원소 교체
3. 맨 앞의 원소를 제외한 배열의 나머지 원소들에 대해 1~2 반복.

![image](https://github.com/eunjjungg/TIL/assets/100047095/d2b43421-4b42-4d43-867b-b2fb4ab54557)
=> 계속 최솟값을 찾고 그 그걸 순차적으로 첫번째부터 정해진 위치에 넣어주는 방식임.

<br/>

### 2. 복잡도

**시간복잡도**

| best | avg | worst |
|-----|-----|-----|
| n^2 | n^2 | n^2 |
▶️ 단순하지만 비효율적인 방법<br/>
위치 선택을 위한 O(n), 최솟값을 찾기 위한 비교 O(n) => O(n^2)

<br/>

**공간복잡도**

다른 자료구조를 사용하지 않음. in-place 알고리즘임. (입력한 배열 이외에 다른 추가 메모리 공간을 요구하지 않음.)

<br/>

### 3. code

```kotlin
var min: Int
// 마지막 값은 정렬할 필요 없으므로 0 until n - 1
for (i in 0 until n - 1) {
    // 초기 index를 최솟값 index로 설정
    min = i
    // 초기 index의 다음 index부터 마지막 index까지 순회
    for (j in i+1 until n) {
        // 값 비교 후 mininum index 변경
        if (array[min] > array[j]) min = j
    }
    // 최솟값을 앞에 배치
    swap(array, i, min)
}
```

<br/>

### 4. 장단점

**장점**

- 단순함
- 다른 메모리 공간을 필요로 하지 않음

**단점**

- 비효율적임

<br/>

### 5. Ref


