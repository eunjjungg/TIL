## LIS, 최장 증가 부분 수열 알고리즘

> 원소가 n개인 배열의 일부 원소만 골라내어 만든 부분 수열 중 -> 
> 각 원소가 이전 원소보다 크다는 조건을 만족하고 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 함. <br/>
> 🚧 단, 각 원소의 index 위치를 임의로 바꾸면 안 됨. 왜냐면 정렬하는 알고리즘이 아니기 때문. 

e.g. [1, 3, 5, 4, 6, 8]의 LIS => [1, 3, 4, 6, 8]

<br/>

### 1. 알고리즘 
사용할 수 있는 알고리즘은 두 가지임. 
1. DP: O(N^2)
   1. 조금 더 간편하게 구현할 수 있는 대신 시간복잡도가 매우 큼. 
2. Lower Bound: O(NlogN)
   1. 복잡한 대신 시간복잡도가 작음. 

### 2. DP
```kotlin
import kotlin.math.max

for(k in 0 until n) {
    length[k] = 1
    for (i in 0 until k) {
        if (arr[i] < arr[k]) {
            length[k] = max(length[k], length[i] + 1)
        }
    }
}
```
- arr 배열은 원래 우리가 LIS를 찾고자 하는 배열임.
- length는 arr의 size만큼 크기를 갖고 있으며 각 index가 의마하는 것은 다음과 같음. 
- length[i]는 i번째 인덱스에서 끝나는 LIS의 길이를 의미함. 

<br/>

### 3. 이분탐색 
![image](https://github.com/eunjjungg/TIL/assets/100047095/ed52c1b4-b484-4f56-949e-5ee1df2159b9)


<br/>

### 4. Ref
- https://chanhuiseok.github.io/posts/algo-49/
- https://gyoogle.dev/blog/algorithm/LIS.html