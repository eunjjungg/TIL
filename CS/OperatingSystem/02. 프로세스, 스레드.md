## 프로세스, 스레드

### 1. 용어 정의
- 프로그램: 파일이 저장장치에는 있지만 **메모리에는 올라가지 않은** **정적인** 상태
  - 메모리에는 올라가 있지 않은: 아직 OS가 프로그램에게 독립적인 메모리 공간을 할당해주지
  않은 상태. 모든 프로그램은 운영체제가 실행되기 위한 메모리 공간을 할당해줘야 실행할 수 있음.
  - 정적인 상태: 아직 실행되지 않은 상태 
- 프로세스: 운영체제로부터 **자원을 할당받은 작업**의 단위. (LINUX에서는 Job이라고도 함.)
    프로그램을 메모리 상에서 실행중인 작업임.
  - 운영체제로부터 할당 받는 자원
    - CPU 시간
    - 운영되기 위한 공간
    - code: 코드 자체를 구성하는 메모리 영역 
    - stack: 지역변수, 매개변수, 리턴값 
    - data: 전역변수, 정적변수, 배열 
    - heap: 동적 할당 시 사용(e.g. malloc, new)
- 스레드: 프로세스 안에서 실행되는 흐름 단위로 CPU 작업 수행의 기본 단위임. 

💬 i.e. 코드 덩어리의 프로그램 -> 실행 위해서 파일이 메모리에 올라가게 됨 ->
동적인 상태가 되고 이게 프로세스가 됨. 

![image](https://github.com/eunjjungg/TIL/assets/100047095/8a42a273-6683-4319-b7a4-c0831a389f7a)

- code, data, heap은 공유됨.
- 프로세스는 스레드를 최소 한 개 이상을 가짐.
- stack은 스레드 당 하나 배정.

💬 i.e. 프로세스는 자신만의 고유 공간과 자원을 할당받는데, 스레드는 다른 스레드와
공간, 자원을 공유하면서 사용함.

<br/>

### 2. 멀티 프로세스
- 여러개의 CPU를 사용해 여러 프로세스를 동시에 수행하는 것.
- 하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 병렬적으로 수행.

#### 장점
- 안전성이 높아짐. 
  - 프로세스 간의 독립성을 보장하므로 프로세스 간 메모리 침범 문제를 운영체제 단에서 해결함.
  - 프로그램을 구성하는 프로세스 중 하나의 프로세스가 문제가 발생하여도 그 프로세스만 죽고 나머지에 영향을 끼치지 않음. 문제가 확산되지 않음.

#### 단점
- [context switching](#3-context-switching) 과정에서 캐시 초기화 같은 작업으로 인한 오버헤드가 발생할 수 있음.
- 프로세스끼리 공유하는 데이터가 없기에 context switching으로 이전 프로세스의 작업 정도를
복구하는 과정이 필요한데, 이것 없이 프로세스끼리 데이터를 공유하려면 [IPC(Inter-Process Communication)](#4-ipc)을 사용해야 되는데 이 방법을
채택하더라도 자원 공유를 위한 추가적인 작업이 필요하다는 단점이 있음.

<br/>

### 3. context switching

- CPU에서 여러 프로세스를 돌아가면서 작업을 처리하기 위해 수행되는 것. 
- 동작중인 프로세스가 대기를 하면서 해당 프로세스의 context를 보관하고
대기하던 다음 프로세스가 동작하여 또 이것의 보관된 context를 복구하는 일련의 과정임.
- 즉 교체로 일어나는 일련의 작업들이 context switching임.
- 멀티 프로세스를 구현하기 뿐 아니라 멀티 스레드를 구현하기 위해서도 필요함.
- context switching이 일어날 때 시스템은 아무 작업을 할 수 없으므로
순수한 오버헤드 시간임. 

> 아래는 공룡책, 3.2.3 문맥 교환 정리해둔 것

- 인터럽트는 운영체제가 씨퓨 코어를 현재 작업에서 뺏어 내어 커널 루틴을 실행할 수 있음.
- 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 context를 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있음.
- 문맥은 프로세스의 PCB에 표현됨.
- 문맥은 CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함함.
- CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요함.
- 문맥 교환이 일어나면 커널은 과거 프로세스의 컨텍스트를 PCB에 저장하고 실행이 스케줄된 새로운 프로세스의 저장된 context를 복구함.
- 문맥 교환이 일어날 동안 시스템이 아무것도 못하므로 순수 오버헤드 시간임.

![image](https://github.com/eunjjungg/TIL/assets/100047095/02e0cc37-b2bf-4a37-99be-afda06073470)

<br/>

### 4. IPC
- Inter Process Communication 
- 프로세스가 다른 프로세스의 정보에 접근하는 것으로 CPU 레지스터 교체, RAM-CPU 사이의 캐시메모리 초기화까지 필요하므로
자원 부담이 큼
- IPC는 공유 메모리, 메시지 전달 두 가지 모델이 있음.

<br/>

### 5. 멀티 스레드
- 하나의 프로세스 내에서 둘 이상의 스레드가 동시에 작업을 수행하는 것. 

#### 장점
- 응답성: 싱글 스레드인 경우 작업이 끝나기 전까지 사용자에게 응답을 할 수 없지만 멀티
스레드에서는 실시간으로 사용자에게 응답을 할 수 있음.
- 자원 공유: 스레드는 자신이 속한 프로세스의 스레드들과 메모리, 자원을 공유할 수 있음. => 문맥교환 비용 감소
  - 스레드에도 문맥 교환 시 오버헤드가 발생하기는 하지만, 프로세스간의 비용보다는 훨씬 적음.
  - why? 공유자원 제외 자신의 정보 관련만 교체해주면 되기 때문.
- 경제성: 프로세스 생성보다 스레드 생성 비용이 훨씬 적음.

#### 단점
- 안전성 문제: 하나의 스레드가 데이터 공간을 망가뜨리면 모든 스레드가 작동 불능이 됨.
- 동기화 문제: 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제.
  - 해결 방법으로는 mutex, semaphore 등이 있는데 뒤에 나옴. 
- 데드락 문제: 서로 필요한 자원을 서로 선점해서 발생하는 무한 루프. 
  - 해결 방안: 상호 배제(Mutual Exception), 점유와 대기(Hold & Wait), 비선점(no preemption), 순환 대기(Circular Wait)
- 많은 스레드가 있으면 결국 context switching overhead가 발생함. 무조건적으로 많은 스레드가 좋은 것은 아님.


<br/>

### 6. Ref
- https://gyoogle.dev/blog/computer-science/operating-system/Process%20vs%20Thread.html
- https://velog.io/@tenacious_mzzz/%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%94%A9-vs-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4
- https://carnival.tistory.com/46
- 운영체제 공룡책