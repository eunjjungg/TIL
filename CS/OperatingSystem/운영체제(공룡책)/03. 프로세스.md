                           ## chapter 3. 프로세스 

### 3.1 프로세스 개념
- 프로세스란 실행 중인 프로그램을 말함. 현대의 컴퓨팅 시스템에서 작업의 단위.
- 프로세스의 현재 활동의 상태는 PC(프로그램 카운터) 값과 프로세서 레지스터의 내용으로 나타냄.

![image](https://github.com/eunjjungg/TIL/assets/100047095/c090dfb9-ad0c-49cd-92db-e8a1b092bbc8)
- 프로세스의 메모리 배치이며 다음과 같이 구성됨.
    - 텍스트 섹션: 코드 부분
    - 데이터 섹션: 전역 변수
    - 힙 섹션: 프로그램 실행 중에 동적으로 할당되는 메모리
    - 스택 섹션: 함수를 호출할 때 임시 데이터 저장장소(e.g. 함수 매개변수, 복귀 주소, 지역 변수 )
- 텍스트 섹션과 데이터 섹션은 크기 고정
- 스택, 힙 섹션은 프로그램 실행 중 동적으로 줄어들거나 커질 수 있음.
- 함수가 호출될 때마다 함수 매개변수, 지역 변수, 복귀 주소를 포함하는 활성 레코드가 스택에 푸시 됨. 함수에서 제어권이 돌아오면
  스택에서 활성 레코드가 팝 됨.
- 스택, 힙 섹션이 커지더라도 운영체제는 이를 겹치지 않게 해야 함.
- 프로그램 != 프로세스
- 프로그램은 그저 디스크에 저장된 파일임.

<br/>

### 3.1.2 프로세스 상태
프로세스는 실행되면서 그 상태가 변함.
프로세스는 아래의 상태 중 하나에 있게 됨.
![image](https://github.com/eunjjungg/TIL/assets/100047095/64eb582d-fb18-4a84-a85f-1f7b5db25108)

- new: 프로세스가 생성 중
- 실행: 명령어들이 실행되고 있음
- 대기: 프로세스가 어떤 이벤트(e.g. 입출력 완료)가 일어나기를 기다림
- 준비: 프로세스가 처리기에 할당됨
- 종료: 프로세스의 실행이 종료됨.

<br/>

### 3.1.3 프로세스 제어 블록
프로세스는 운영체제에서 프로세스 제어 블록(PCB)로 표현됨.
![image](https://github.com/eunjjungg/TIL/assets/100047095/d80a40de-9fe1-4f30-a197-14d28a011160)
- 프로세스 상태: 3.1.2의 상태 중 하나 보유
- 프로그램 카운터: 이 프로세스가 다음에 실행할 명령어의 주소
- CPU 레지스터: 레지스터 + 상태 코드가 포함되며 프로그램 카운터와 함께 이 정보는 나중에 프로세스가 다시 스케줄 될 때
  올바르게 실행되도록 하기 위해 인터럽트 발생 시 저장되어야 함.
    - 레지스터에는 누산기, 인덱스 레지스터, 스택 레지스터, 범용 레지스터 등등이 있음.
- CPU 스케줄링 정보: 프로세스 스케줄링 관련 정보
- 메모리 관리 정보: 메모리 관련 정보..
- 나머지는 굳이 몰라도 될듯.

<br/>

### 3.1.4 스레드

<br/>

### 3.2 프로세스 스케줄링
- 시분할의 목적은 각 프로그램이 실행되는 동안 사용자가 상호 작용할 수 있도록 프로세스 사이에서 CPU 코어를 빈번히 교체하는 것
- 이를 달성하기 위해 프로세스 스케줄러는 코어에서 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택함.
- I/O 바운드 프로세스: 계산에 소비하는 것보다 I/O에 더 많은 시간을 소비하는 프로세스
- CPU 바운드 프로세스: 계산에 더 많은 시간을 사용하여 I/O 요청을 자주하지 않음.

<br/>

### 3.2.1 스케줄링 큐
프로세스가 시스템에 들어가면 준비 큐에 들어가서 준비 상태가 되어 CPU 코어에서 실행되기를 대기함.
프로세스에 CPU 코어가 할당되면 프로세스는 잠시 동안 실행되어 결국 종료되거나 인터럽트 되거나 I/O 요청의 완료와 같은
특정 이벤트가 발생할 때까지 기다림. I/O 요청을 할 수도 있는데 요청하면 입출력 장치는 느리므로 사용 가능할 때까지
대기해야 함. I/O 완료와 같은 특정 이벤트가 발생하기를 기다리는 프로세스는 대기 큐에 삽입됨.
- 새 프로세스는 처음에 준비 큐에 놓임. 프로세스는 실행을 위해 선택되거나 또는 디스패치 될 때까지 기다림.
- 프로세스에 CPU 코어가 할당되고 실행 상태가 되면 여러 이벤트 중 하나가 발생할 수 있음. 아래는 그 이벤트의 예시임.
    - 프로세스가 I/O 요청을 공표하고 I/O 대기 큐에 놓일 수 있음.
    - 프로세스는 새 자식 프로세스를 만든 다음 자식의 종료를 기다리는 동안 대기 큐에 놓일 수 있음.
    - 인터럽트가 발생하거나 타임 슬라이스가 만료되어 프로세스가 강제로 코어에서 제거되어 준비 큐로 돌아갈 수 있음.

<br/>

### 3.2.2 CPU 스케줄링
씨퓨 스케줄러의 역할은 준비 큐에 있는 프로세스 중에서 선택된 하나의 프로세스에 CPU core를 할당하는 것임.
- I/O 바운드 프로세스: I/O 요청을 대기하기 전에 몇 밀리초만 실행될 수 있음.
- CPU 바운드 프로세스: 오랜 시간동안 씨퓨가 필요하지만 스케줄러는 프로세스에게 코어를 장기간 부여할 가능성이 없다.

<br/>

### 3.2.3 문맥 교환
- 인터럽트는 운영체제가 씨퓨 코어를 현재 작업에서 뺏어 내어 커널 루틴을 실행할 수 있음.
- 인터럽트가 발생하면 시스템은 인터럽트 처리가 끝난 후에 context를 복구할 수 있도록 현재 실행 중인 프로세스의 현재 문맥을 저장할 필요가 있음.
- 문맥은 프로세스의 PCB에 표현됨.
- 문맥은 CPU 레지스터의 값, 프로세스 상태, 메모리 관리 정보 등을 포함함.
- CPU 코어를 다른 프로세스로 교환하려면 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업이 필요함.
- 문맥 교환이 일어나면 커널은 과거 프로세스의 컨텍스트를 PCB에 저장하고 실행이 스케줄된 새로운 프로세스의 저장된 context를 복구함.
- 문맥 교환이 일어날 동안 시스템이 아무것도 못하므로 순수 오버헤드 시간임.

![image](https://github.com/eunjjungg/TIL/assets/100047095/02e0cc37-b2bf-4a37-99be-afda06073470)

<br/>

### 3.3 프로세스에 대한 연산
- 프로세스는 여러 자식 프로세스를 생성할 수 있고 부모-자식 관계를 맺음.
- pid(프로세스 식별자)를 사용하여 프로세스를 구분
- pid는 커널이 유지하고 있는 프로세스의 다양한 속성에 접근하기 위한 인덱스로 사용됨.

<br/>

### 3.4 프로세스 간 통신
- 운영체제 내에서 실행되는 병행 프로세스들은 독립적이거나 협력적인 프로세스들일 수 있음.
- 독립은 서로 데이터 공유하지 않는 프로세스고 협력적인건 서로 데이터 공유하는 프로세스임.
- IPC 기법으로 프로세스 간 통신을 함.
- IPC는 공유 메모리, 메시지 전달 두 가지 모델이 있음.

<br/>

### 3.5 공유 메모리 시스템에서의 프로세스 간 통신
- 통신하는 프로세스들이 공유 메모리를 구축해야 함.
- 이 공유 메모리 세그먼트를 사용하는 프로세스들은 이 세그먼트를 자신의 주소 공간에 추가하여야 함.

<br/>

### 3.6 메시지 전달 시스템에서의 프로세스 간 통신
- 운영체제가 메시지 전달 설비를 통하여 서로 협력하는 프로세스 간의 통신 수단을 제공해 주는 방법

<br/>

### 3.7 ~ 3.8
- 넘김
- IPC 관련 상세 내용

<br/>

### 3.9 요약
- 프로세스는 실행 중인 프로그램이며 프로세스의 현재 활동 상태는 PC, 다른 레지스터로 나타냄
- 메모리에서 프로세스의 레이아웃은 텍스트, 데이터, 힙, 스택 네 가지 섹션으로 표시됨
- 프로세스가 실행되면 상태(준비, 실행, 대기, 종료)가 변경됨.
- 프로세스 제어 블록은 운영체제의 프로세스를 나타내는 커널 데이터 구조임.
- 프로세스 스케줄러의 역할은 씨퓨에서 실행할 수 있는 사용 가능한 프로세스를 선택하는 것
- 운영체제는 한 프로세스 실행에서 다른 프로세스 실행으로 전환할 때 문맥 교환을 수행함. 