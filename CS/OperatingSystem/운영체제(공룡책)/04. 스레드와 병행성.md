## chapter 4. 스레드와 병행성

> 현대 운영체제는 한 프로세스가 다중 스레드를 포함하는 특성을 제공함.

<br/>

### 4.1 개요
- 스레드는 씨퓨 이용의 기본 단위
- 스레드 구성: 스레드 ID, PC, 레지스터 집합, 스택 
- 스레드는 같은 프로세스에 속한 다른 스레드와 코드, 데이터 섹션, 기타 운영체제 자원들을 공유함. 

<br/>

### 4.1.1 동기
하나의 응용 프로그램이 여러 개의 비슷한 작업을 수행할 필요가 있는 상황들이 있음. 
만일 웹 서버가 단일 스레드 프로세스로 작동한다면 클라이언트의 대기 시간이 길어지게 됨. 
이걸 해소하기 위해 다중 프로세스로 하자기에는 문맥 교환 비용 감당이 부담스러움. 
따라서 다중 스레드 환경이 등장.

<br/>

### 4.1.2 장점 
- 응답성: 단일 스레드 응용프로그램은 사용자가 버튼을 눌렀을 때 버튼으로 인해 발생하는
연산이 종료될 때까지 응용프로그램이 사용자에게 응답하지 않음. 그러나 이 연산이 비동기적 스레드에서
실행된다면 응용프로그램은 여전히 사용자에게 응답할 수 있음.
- 자원 공유 & 경제성: 프로세스는 IPC 기법을 사용해야만 자원 공유가 되고 추가적으로 프로그래머의 처리가 필요함.
그러나 스레드는 그럴 필요가 없고 또한 문맥 교환으로 발생하는 오버헤드도 적음. 또한 스레드 생성 비용이
프로세스 생성 비용보다 적음.
- 규모 적응성(scalability): 이해 못함 뭔소리고 (p.178)

<br/>

### 4.2 다중 코어 프로그래밍 
단일 CPU 시스템에서 발전된게 다중 CPU 시스템.
나중엔 단일 컴퓨팅 칩에 여러 컴퓨팅 코어를 배치하여 각 코어는 OS에 별도의 CPU로 보이는 다중 코어 시스템을 채택. 
다중 스레드 프로그래밍은 이런 다중 코어 상황을 효율적으로 사용하는 기법을 제공
- 병행성: 모든 작업이 진행되게 하여 둘 이상의 작업을 지원함.
- 병렬성: 둘 이상의 작업을 도시에 수행할 수 있음.

<br/>

### 4.2.1 프로그래밍 도전과제
#### 다중코어 시스템 설계 시 과제
- 태스크 인식: 애플리케이션을 분석하여 각각 독립된 병행 간으 태스크로 나눌수 있어야 함. 이 태스크는 
서로 독립적이고 개별 코어에서 병렬 실행될 수 있어야 함.
- 균형: 병렬로 실행될 수 있는 태스크들이 각각 전체 작업에 귣능한 기여도를 가지도록 해야함.
- 데이터 분리: 분리된 태스크가 접근하고 조작하는 데이터 또한 개별 코어에서 사용할 수 있도록 분리되어야 함.
- 데이터 종속성: 태스크가 접근하는 데이터는 둘 이상의 태스크 사이에 종속성이 없는지 검토되어야 함. 
- 시험 및 디버깅: 문제 없이 잘 되어라~ 

<br/>

### 4.2.2 병렬 실행의 유형 
![image](https://github.com/eunjjungg/TIL/assets/100047095/b6cb91ce-a06c-47bd-8eec-b0048a453d38)
> Task Paralism을 Data Parallelism과 비교해 이해해보자. 
> <br/>Data parallelism은 동일한 메커니즘의 반복적수행을 병렬화하는 것이다. 
> <br/>반면 Task Parallelism은 동일한 Data 혹은 서로 다른 Data 들에 대하여 서로 다른 작업들을 병렬적으로 수행하기 위한 방법이다.
> <br/>출처: https://next-brain.tistory.com/31

#### 데이터 병렬 실행
- 동일한 데이터의 부분집합을 다수의 계산 코어에 분배한 뒤 각 코어에서 동일한 연산을 실행하는데 초점을 맞춤.
- e.g. 0 ~ N까지의 덧셈을 반으로 나누어서 수행.
- 여러 코어에 데이터를 분배하는 것이 포함됨.

<br/>

#### 태스크 병렬 실행
- 데이터가 아니라 태스크를 다수의 코어에 분배함. 
- 여러 코어에 태스크를 분배하는 것이 포함됨. 

i.e. 상호 배타적이지 않고 두 가지 전략 모두 혼합하여 사용함. 

<br/>

### 4.3 다중스레드 모델 
- 사용자 스레드는 사용자를 위한 수준에서 커널 스레드는 커널을 위한 수준에서 제공됨. 
- 사용자 스레드와 커널 스레드는 연관관계가 존재해야 하는데 다대일 모델, 일대일 모델, 다대다 모델 중 하나를 채택함.

<br/>

### 4.3.1 다대일 모델 
![image](https://github.com/eunjjungg/TIL/assets/100047095/a8c27596-f7dd-46ee-9e13-1ddbc0ec6b4e)
- many-to-one 모델은 많은 사용자 수준 스레드를 하나의 커널 스레드로 매핑함. 
- 스레드 관리는 사용자 공간의 스레드 라이브러리에 의해 수행됨.
- 한 스레드가 봉쇄형 시스템 콜을 하면 전체 프로세스가 봉쇄됨. 
- 한 스레드만이 커널에 접근할 수 있으므로 다중 스레드가 다중 코어 시스템에서 병렬로 실행될 수 없음. 따라서 현재에는 아무도 안 씀.

<br/>

### 4.3.2 일대일 모델
![image](https://github.com/eunjjungg/TIL/assets/100047095/5c9f8a9f-1ecd-44ba-a453-cfe190e33993)
- one-to-one 모델은 각 사용자의 스레드를 각각 하나의 커널 스레드로 매핑함.  
- 한 스레드가 봉쇄형 시스템 콜 호출해도 다른 스레드가 실행됨. 
- 다중 처리기에서 다중 스레드가 병렬로 수행되는 것을 허용함.
- 사용자 스레드를 만들려면 커널 스레드를 만들어야 함. => 시스템 부담 초래

<br/>

### 4.3.3 다대다 모델
![image](https://github.com/eunjjungg/TIL/assets/100047095/2280052b-1350-4d00-8d62-4b3ed538e482)
- many-to-many 모델은 여러 개의 사용자 수준 스레드를 그보다 작거나 같은 수의 커널 스레드로 매핑함.
- 다대일 모델은 사용자 수준 스레드의 생성에서 자유롭지만 병렬 실행이 불가능함. 
일대일 모델은 더 많은 병행성 제공하지만 커널 스레드가 너무 많아지지 않도로 주의해야 함.
다대다 모델은 위 두 모델의 단점을 어느정도 보완함. 
- 봉쇄형 시스템 콜을 해도 다른 스레드가 여전히 수행 가능함. 
- 다대다 모델의 변형은 일대일 + 다대다 모델을 섞어서 사용하는 two-level model이 있음. 
- 구현이 힘듦. 
- 대부분의 시스템에서 처리 코어 수가 증가함에 따라 커널 스레드의 수를 제한하는 것의 필요성이 줄어 사실상 다대다 모델이
융통성 있어 보이지만 최근 운영체제들은 대부분 일대일 모델을 사용함. 

<br/>

### 4.4 스레드 라이브러리 
스레드 라이브러리는 프로그래머에게 스레드를 생성하고 관리하기 위한 API를 제공함. 
- 구현 방법 1: 커널의 지원 없이 유저 공간에서만 라이브러리 제공
- 구현 방법 2: 운영체제에 의해 지원되는 커널 수준 라이브러리를 구현하는 것
4.4 이하 내용 생략 (너무 지엽적임.)

<br/>

### 4.5 암묵적 스레딩, Implicit Threading
- 스레딩의 생성과 관리 책임을 개발자가 아닌 컴파일러와 런타임 라이브러리에게 넘기는 것.
- 이 절에서는 암묵적 스레딩을 이용하여 다중 코어 처리기를 활용할 수 있는 애플리케이션 설계 방법에 대해 설명함.
