# item 16. 프로퍼티는 동작이 아니라 상태를 나타내야 한다

### 코틀린의 프로퍼티 - 1: 개념

코틀린의 프로퍼티는 자바의 필드와 비슷해보이지만 다름. 둘 다 데이터를 저장한다는 점은 같지만 프로퍼티는 사용자 정의 getter, setter를 가질 수 있다는 점에서 다름. 

```kotlin
var name: String? = null
    get() = field?.toUpperCase()
    set(value) {
        if (!value.isNullOrBlank()) {
            field = value
        }
    }
```

`getter`, `setter`에서의 `field`라는 식별자는 프로퍼티의 데이터를 저장해 두는 백킹 필드(backing field)에 대한 레퍼런스임. 백킹 필드는 세터와 게터의 디폴트 구현에 사용되므로 따로 만들지 않아도 됨. `val`로 읽기 전용 프로퍼티를 만들 때는 `field`가 만들어지지 않음. `var`을 사용해서 만든 프로퍼티에서는 게터와 세터를 정의할 수 있으며 이런 프로퍼티를 파생 프로퍼티(derived property)라고 부름. 

프로퍼티는 필드가 필요 없음. 오히려 프로퍼티는 개념적으로 접근자(getter, setter)를 나타냄. 따라서 코틀린은 인터페이스에도 프로퍼티를 정의할 수 있음. 그리고 같은 이유로 프로퍼티를 위임할 수 있음. (`by`)

> 스터디 때 이 부분이 잘 이해되지 않아 질문을 함. 결과적으로 정리된 내용은 아래와 같음.
프로퍼티를 선언해도 getter, setter, field를 자동으로 생성하고 이 인터페이스를 implementation 시 이를 override하므로 interface에 프로퍼티가 사용 가능함. 반면 자바에서는 인터페이스에 변수가 없음. 상수만 된다고 함.
> 

<br/>

### 코틀린의 프로퍼티 - 2: 확장 프로퍼티

프로퍼티는 본질적으로 함수이므로 확장 프로퍼티를 만들 수도 있음. 

```kotlin
val Context.preferences: SharedPreferences
		get() = PreferenceManager.getDefaultSharedPreferences(this)
```

코드에서 나타내는 것처럼 프로퍼티는 필드가 아니라 접근자를 나타냄. 이처럼 프로퍼티를 함수 대신 사용할 수 있지만, 그렇다고 완전히 대체해서 사용하면 절 대 안 됨. 프로퍼티로 알고리즘의 동작을 나타내는 것은 좋지 않음. (내가 많이 하던 짓임…) 

**즉 프로퍼티는 상태를 나타내거나 설정하기 위한 목적으로만 사용하는 것이 좋고 다른 로직을 포함하지 않아야 함.** 이걸 판단하는 방법은 이 프로퍼티를 함수로 정의할 경우 접두사로 `get`, `set`을 붙일 수 없다면 프로퍼티가 아닌 함수로 만들어주어야 함. 

<br/>

### 코틀린의 프로퍼티 - 3: 프로퍼티 대신 함수가 더 좋은 경우

1. 연산 비용이 높거나, 복잡도가 O(1)보다 큰 경우: 프로퍼티를 관습적으로 사람들은 연산 비용이 많이 필요하다고 생각하지 않음. 그러나 연산 비용이 많이 들어간다면 함수를 사용하는 것이 좋음. 그래야 사용자가 연산 비용 예측과 캐싱을 고려할 수 있음.
2. 비즈니스 로직을 포함하는 경우: 관습적으로 사람들은 프로퍼티가 로깅, 리스너 통지, 바인드된 요소 변경과 같은 단순한 동작 이상을 할 것이라고 예측하지 않음.
3. 결정적이지 않은 경우: 같은 동작을 연속적으로 두 번 했는데 다른 값이 나올 수 있다면 함수를 사용하는 것이 좋음. (이것도 로직이 들어간 거라고 이해하면 될듯)
4. 변환의 경우: 변환은 보통 `Int.toDouble()`과 같은 변환 함수로 이루어짐. 
5. 게터에서 프로퍼티의 상태 변경이 일어나야 하는 경우

위는 프로퍼티 사용 대신 함수를 고려해봐야 하는 경우이고 반대로 프로퍼티를 함수 대신 사용하는 것이 좋은 경우는 상태를 설정/추출할 때이다.
