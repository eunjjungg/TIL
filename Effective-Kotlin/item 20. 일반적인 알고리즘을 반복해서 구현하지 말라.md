# item 20. 일반적인 알고리즘을 반복해서 구현하지 말라

### 이미 있는 알고리즘을 사용하라

```kotlin
// 1
val percent = when { 
		numberFromUser > 100 -> 100 
		numberFromUser < 0 -> 0 
		else -> numberFromUser
}

// 2 
val percent = numberFromUser.coerceIn(0, 100)
```

위의 코드에서 1번처럼 다 구현하는 것보다 2번처럼 이미 있는 것을 활용하는 것이 더 좋음 그 이유는 아래와 같음.

- 코드 작성 속도가 빨라짐.
- 구현을 읽지 않아도 ㅎ마수의 이름 등만 보고도 무엇을 하는 것인지 확실하게 알 수 있음.
- 직접 구현할 때 발생할 수 있는 실수를 줄일 수 있음.
- 제작자들이 최적화하면 이러한 함수를 활용하는 모든 곳이 최적화의 혜택을 받을 수 있음.

<br/>

### 실제 사용

- 표준 라이브러리인 stdlib에서 사용
- 표준 라이브러리에 없는 알고리즘이 필요한 경우 널리 알려진 추상화라면 범용 유틸리티 함수로 정의하는 것도 좋음.

두 번째와 같이 직접 구현하면 동일한 결과를 얻는 함수를 여러 번 만들 필요도 없어짐. 이와 같이 많이 사용되는 알고리즘을 추출하는 방법으로는 확장 함수 외에도 top level function, property delegation, class 등이 있음. 확장 함수는 이러한 방법들과 비교해서 아래의 장점을 가지고 있음.

- 함수는 상태를 유지하지 않으므로, 행위를 나타내기 좋음.
- 톱 레벨 함수와 비교해서 확장 함수는 구체적인 타입이 있는 객체에만 사용을 제한할 수 있음.
- 수정할 객체를 아규먼트로 전달받아 사용하는 것보다는 확장 리시버로 사용하는 것이 가독성 측면에서 더 좋음.
- 확장 함수는 객체에 정의한 함수보다 객체를 사용할 때 IDE의 자동완성 기능으로 제안이 이루어지므로 쉽게 찾을 수 있음.

> top-leve function: 컴파일 되면 오브젝트 클래스의 파일이 만들어지고 그 함수가 내부로 들어가게 됨.
>
